/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package aoc;

import static java.lang.Integer.parseInt;
import static java.util.stream.Collectors.toList;
import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.regex.Pattern;
import java.util.stream.Stream;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

/** https://adventofcode.com/2022/day/4 */
class Day4Test {
  static Pattern RANGE = Pattern.compile("(\\d+)-(\\d+),?");

  static Stream<Arguments> args() throws Exception {
    return Stream.of(
        Arguments.of(
            """
            2-4,6-8
            2-3,4-5
            5-7,7-9
            2-8,3-7
            6-6,4-6
            2-6,4-8"""
                .lines(),
            2,
            true),
        Arguments.of(
            new String(Day1Test.class.getResourceAsStream("/input4.txt").readAllBytes()).lines(),
            605,
            true),
        Arguments.of(
            """
            2-4,6-8
            2-3,4-5
            5-7,7-9
            2-8,3-7
            6-6,4-6
            2-6,4-8"""
                .lines(),
            4,
            false),
        Arguments.of(
            new String(Day1Test.class.getResourceAsStream("/input4.txt").readAllBytes()).lines(),
            765,
            false));
  }

  record SectionAsignment(int from, int to) {
    public boolean contains(SectionAsignment other) {
      return other.from() >= from && other.to() <= to;
    }

    public boolean overlaps(SectionAsignment other) {
      return other.to() >= from && other.from() <= to;
    }
  }

  int solve(Stream<String> lines, boolean partOne) {
    return (int)
        lines
            .filter(
                (line) -> {
                  var shifts =
                      RANGE
                          .matcher(line)
                          .results()
                          .map(
                              shift ->
                                  new SectionAsignment(
                                      parseInt(shift.group(1)), parseInt(shift.group(2))))
                          .collect(toList());
                  var shiftA = shifts.get(0);
                  var shiftB = shifts.get(1);
                  if (!partOne) {
                    if (!shiftA.overlaps(shiftB)) {
                      System.out.println(
                          "shift %s and %s do not overlap".formatted(shiftA, shiftB));
                    }
                  }
                  return partOne
                      ? shiftA.contains(shiftB) || shiftB.contains(shiftA)
                      : shiftA.overlaps(shiftB);
                })
            .count();
  }

  @ParameterizedTest
  @MethodSource("args")
  void test(Stream<String> lines, int expected, boolean partOne) throws Exception {
    assertEquals(expected, solve(lines, partOne));
  }
}
