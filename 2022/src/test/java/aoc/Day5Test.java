/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package aoc;

import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Stream.concat;
import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.ArrayDeque;
import java.util.List;
import java.util.regex.Pattern;
import java.util.stream.Stream;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

/** https://adventofcode.com/2022/day/6 */
class Day5Test {
  private static final Pattern CRATE = Pattern.compile("\\[(\\S)\\]");
  private static final Pattern INSTRUCTION = Pattern.compile("move (\\d+) from (\\d+) to (\\d+)");

  record Crate(String label) {}

  static Stream<Arguments> args() throws Exception {
    return Stream.of(
        Arguments.of(
            """
            [D]
            [N] [C]
            [Z] [M] [P]
             1   2   3

            move 1 from 2 to 1
            move 3 from 1 to 3
            move 2 from 2 to 1
            move 1 from 1 to 2"""
                .lines(),
            "CMZ",
            true));
  }

  String solve(Stream<String> lines, boolean partOne) {
    var results =
        lines.reduce(
            List.<ArrayDeque<String>>of(),
            (stacks, line) -> {
              var crates =
                  CRATE
                      .matcher(line)
                      .results()
                      .map(res -> new Crate(res.group(0)))
                      .collect(toList());

              return stacks;
            },
            (prev, next) -> concat(prev.stream(), next.stream()).toList());
    return results.stream().map(ArrayDeque::pop).collect(joining());
  }

  @ParameterizedTest
  @MethodSource("args")
  void test(Stream<String> lines, String expected, boolean partOne) throws Exception {
    assertEquals(expected, solve(lines, partOne));
  }
}
