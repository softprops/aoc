/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package aoc;

import static java.lang.Integer.parseInt;
import static java.util.Collections.reverse;
import static java.util.stream.Collectors.collectingAndThen;
import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toList;
import static java.util.stream.IntStream.range;
import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Optional;
import java.util.regex.Pattern;
import java.util.stream.Stream;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

/** https://adventofcode.com/2022/day/5 */
class Day5Test {
  private static final Pattern CRATE_SLOT = Pattern.compile("([\\s]{3}|\\[(\\S)\\])\\s?");
  private static final Pattern INSTRUCTION = Pattern.compile("move (\\d+) from (\\d+) to (\\d+)");

  record Crate(String label) {}

  static Stream<Arguments> args() throws Exception {
    return Stream.of(
        Arguments.of(
            """
                [D]
            [N] [C]
            [Z] [M] [P]
             1   2   3

            move 1 from 2 to 1
            move 3 from 1 to 3
            move 2 from 2 to 1
            move 1 from 1 to 2"""
                .lines(),
            "CMZ",
            true),
        Arguments.of(
            new String(Day1Test.class.getResourceAsStream("/input5.txt").readAllBytes()).lines(),
            "BWNCQRMDB",
            true),
        Arguments.of(
            """
                  [D]
              [N] [C]
              [Z] [M] [P]
               1   2   3

              move 1 from 2 to 1
              move 3 from 1 to 3
              move 2 from 2 to 1
              move 1 from 1 to 2"""
                .lines(),
            "MCD",
            false),
        Arguments.of(
            new String(Day1Test.class.getResourceAsStream("/input5.txt").readAllBytes()).lines(),
            "NHWZCBNBF",
            false));
  }

  String solve(Stream<String> lines, boolean partOne) {
    var results =
        lines.reduce(
            new ArrayList<ArrayDeque<Crate>>(),
            (stacks, line) -> {
              // if this is a crate line, pack the stacks
              // every slot is either Optional.empty() or Optional.of(new Crate(label))
              CRATE_SLOT
                  .matcher(line)
                  .results()
                  .map(res -> Optional.ofNullable(res.group(2)).map(Crate::new))
                  .reduce(
                      0,
                      (index, slot) -> {
                        if (stacks.size() <= index) {
                          stacks.add(new ArrayDeque<Crate>());
                        }
                        slot.ifPresent(stacks.get(index)::addFirst);
                        return index + 1;
                      },
                      Integer::sum);

              // if this is an instruction line, follow instruction
              INSTRUCTION
                  .matcher(line)
                  .results()
                  .forEach(
                      res -> {
                        var numCrates = parseInt(res.group(1));
                        var src = stacks.get(parseInt(res.group(2)) - 1);
                        var dest = stacks.get(parseInt(res.group(3)) - 1);
                        var crates = range(0, numCrates).mapToObj(ignore -> src.removeLast());
                        if (partOne) {
                          // as is then move
                          crates.forEach(dest::addLast);
                        } else {
                          // reverse then move
                          crates
                              .collect(
                                  collectingAndThen(
                                      toList(),
                                      l -> {
                                        reverse(l);
                                        return l;
                                      }))
                              .stream()
                              .forEach(dest::addLast);
                        }
                      });
              return stacks;
            },
            (prev, next) -> next);

    return results.stream().map(ArrayDeque::getLast).map(Crate::label).collect(joining());
  }

  @ParameterizedTest
  @MethodSource("args")
  void test(Stream<String> lines, String expected, boolean partOne) throws Exception {
    assertEquals(expected, solve(lines, partOne));
  }
}
